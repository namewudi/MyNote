# 内存分区

一般的，C++ 内存分区为：**数据段、代码段、BSS段、堆区、栈区**
 其中， BSS段相对于其他内存区域来说使用较少，而全局区（静态区）包括了BSS段和数据段中的已初始化静态变量，更符合实际编程中的使用情况，所以人们通常会直接把全局区（静态区）作为表示静态变量和全局变量的存储区域。

因此这里按照实用性总结为：**栈区、堆区、全局区（静态区）、常量区、代码区。**在描述完具体分区后，本文继续解释BSS段相关内容。

**1）栈区：**栈区用于存储函数的**局部变量、函数的参数**等数据，它的内存分配和释放是自动完成的，当函数调用结束时，栈区的内存会自动释放。栈区的空间相对较小，通常为几 MB，也不适合存储大量的数据。

**2）堆区（自由存储区）：**堆区用于存储程序动态分配的内存，堆区的内存分配和释放需要手动完成，通过 new & delete （malloc & free） 关键字进行操作。堆区的空间相对较大，可以存储大量的数据，但是需要手动管理内存，否则容易出现内存泄漏和内存溢出等问题。很多编译器的new & delete都是以malloc & free为基础来实现的。

**3）全局区（静态区）：**全局区用于存储**全局变量和静态变量**等数据，它的内存分配和释放在程序启动和结束时完成。全局区的空间相对较大，可以存储大量的数据，但是需要注意全局变量的作用域和生命周期等问题。

**注：与普通局部变量不同的是，静态局部变量的生命周期与全局变量相同，即在程序开始时被创建，在程序结束时被销毁。**
 普通局部变量一般存在于栈区，如果使用new、malloc创建，那么自然在堆区。

**4）常量区：**常量区用于存储程序中的**常量数据，包括字符串常量和数值常量等**。常量区的内存分配在程序编译时完成，**通常是只读的，不能修改其中的数据。**

**5）代码区：**代码区用于存储程序的代码段，包括**函数体和程序指令**等。代码区的内存分配在程序编译时完成，通常是只读的，不能修改其中的数据。


 **数据段**包含**已初始化**的全局、静态变量、常量

**Block Started by Symbol（BSS）**是指在程序运行时，未初始化或初始化为0的全局变量和静态变量所占用的内存区域。BSS段在可执行文件中只占用磁盘空间而不占用内存空间，只有在程序运行时才会被动态地分配内存。

在C语言和C++中，如果全局变量和静态变量没有初始化或初始化为0，则它们会被放在BSS段中。当程序启动时，操作系统会为BSS段分配内存，并将其初始化为0。

例如，下面的代码定义了一个全局变量`int a`，由于没有初始化，它将被放在BSS段中：

```c++
#include <iostream>
using namespace std;

int a;  // 全局变量a将被放在BSS段中

int main() {
    cout << "a = " << a << endl;
    return 0;
}
```

在程序运行时，操作系统会为变量`a`分配内存，并将其初始化为0。这个过程是由操作系统完成的，程序员无需关心。

需要注意的是，BSS段只适用于全局变量和静态变量，局部变量不会放在BSS段中。此外，如果全局变量或静态变量被显式地初始化为非0值，则它们不会被放在BSS段中，而是被放在数据段（Data Segment）中。